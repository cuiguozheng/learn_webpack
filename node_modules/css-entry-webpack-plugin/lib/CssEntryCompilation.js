"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebird = require("bluebird");

var _bluebird2 = _interopRequireDefault(_bluebird);

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _tapable = require("./interop/tapable");

var _tapable2 = _interopRequireDefault(_tapable);

var _webpack = require("./interop/webpack");

var _models = require("./models");

var _CssEntryPluginError = require("./CssEntryPluginError");

var _CssEntryPluginError2 = _interopRequireDefault(_CssEntryPluginError);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: Add spec that it works with dynamic entry (function)
// TODO: Test when two entries share a common file and one entry is excluded (when both are multi)
// TODO: Spec for how many times a condition from options is called
/** @internal */
class CssEntryCompilation extends _tapable2.default {
    constructor(options, compiler, compilation, extractTextPlugin) {
        super();
        this.options = options;
        this.compiler = compiler;
        this.compilation = compilation;
        this.extractTextPlugin = extractTextPlugin;
        this.breakingChangeErrorReported = false;
        this.cssEntries = new Set();
        this.nonCssEntries = new Set();
    }
    /**
     * Called after the NormalModuleFactory has resolved a request.
     * @param data The data for the resolved request.
     */
    onNormalModuleFactoryAfterResolve(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!data.dependencies) {
                this.reportBreakingChange("Could not get 'dependencies' from AfterResolveData");
                return data;
            }
            if (!this.isEntryRequestResolve(data)) {
                return data;
            }
            let depedency = data.dependencies[0];
            let entry = this.extractEntryInfo(depedency);
            if (!entry) return data;
            return yield this.onEntryRequestAfterResolve(entry, data);
        });
    }
    isEntryRequestResolve(data) {
        // Only one dependency is added for an entry module
        // See webpack/lib/Compilation.js: _addModuleChain declaration
        // RISK: Webpack can change and pass multiple SingleEntryDependency instances
        return data.dependencies.length === 1 && data.dependencies[0] instanceof _webpack.SingleEntryDependency;
    }
    /**
     * Extracts entry information from a given SingleEntryDependency.
     * @param dependency The SingleEntryDependency to extract the entry information from.
     * @returns The entry information or null if none could be extracted.
     */
    extractEntryInfo(dependency) {
        if (typeof dependency.loc !== "string") {
            this.reportBreakingChange("Could not get 'loc' from SingleEntryDependency");
            return null;
        }
        let sep = dependency.loc.lastIndexOf(_webpack.multiEntryDependencyLocSeparator);
        let name = sep === -1 ? dependency.loc : dependency.loc.substr(0, sep);
        if (!name) {
            this.addWarning("Entry with no name found");
            return null;
        }
        return {
            isMulti: sep !== -1,
            name: name
        };
    }
    /**
     * Called after the NormalModuleFactory has resolved the request from an entry.
     * @param entry The entry information.
     * @param data The data for the resolved request.
     * @returns A promise that finishes after the plugin logic has finished.
     */
    onEntryRequestAfterResolve(entry, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO: do isCssResource()
            let isCssEntry = yield this.isCssEntry(entry, data);
            if (!isCssEntry) {
                this.nonCssEntries.add(entry.name);
                return data;
            }
            this.cssEntries.add(entry.name);
            if ((0, _webpack.isWebpackDevServerResource)(data.resource)) {
                return data;
            }
            return this.extractCss(data);
        });
    }
    /**
     * Checks if the css from the request of the entry should be extracted.
     * @param entryInfo The entry information.
     * @param data The data for the resolved request.
     * @returns A promise that finishes after the check logic has finished or a boolean.
     */
    isCssEntry(entry, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Skip if already marked as a non-CSS entry
            if (this.nonCssEntries.has(entry.name)) return false;
            // Check configuration options
            if (!this.cssEntries.has(entry.name) && !this.options.includeCssEntry(entry)) return false;
            // Single entry
            if (!entry.isMulti && this.options.isCssResource(data.resource, entry)) {
                // Valid single entry with valid css resource
                return true;
            }
            // Multi entry
            if (entry.isMulti) {
                if (!this.cssEntries.has(entry.name)) {
                    // This is the first time validating this entry
                    return this.isMultiCssEntry(entry);
                }
                // Already validated this, it is a valid css entry
                return true;
            }
            return false;
        });
    }
    isMultiCssEntry(entryInfo) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // We do a check to see if all resources in the entry are valid css resources
            let multiModule = this.findMultiModule(entryInfo);
            if (!multiModule) {
                this.reportBreakingChange("Could not find associated MultiModule of entry");
                return false;
            }
            let resources = yield this.resolveResources(multiModule);
            resources = (0, _webpack.excludeWebpackDevServerResources)(resources);
            let hasOnlyCssResources = resources.every(resource => this.options.isCssResource(resource, entryInfo));
            let taggedModule = multiModule;
            taggedModule[_models.isCssEntry] = hasOnlyCssResources;
            return hasOnlyCssResources;
        });
    }
    resolveResources(module) {
        const resolver = this.compilation.resolvers.normal,
              context = this.compiler.context;
        return (0, _bluebird.all)(module.dependencies.map(depedency => this.resolveResource(resolver, context, depedency)));
    }
    resolveResource(resolver, context, dependecy) {
        return new _bluebird2.default((resolve, reject) => {
            resolver.resolve({}, context, dependecy.request, (err, data) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(data);
                }
            });
        });
    }
    findMultiModule(entryInfo) {
        if (!entryInfo.isMulti) return null;
        for (let module of this.compilation.entries) {
            if (module instanceof _webpack.MultiModule && module.name === entryInfo.name) {
                return module;
            }
        }
        return null;
    }
    extractCss(data) {
        const originalLoaders = data.loaders;
        data.loaders = this.extractTextPlugin.extract({
            use: originalLoaders
        });
        // Recalculate the 'request', this is required
        data.request = (0, _webpack.loadersToRequestIdent)(data.loaders, data.resource);
        return data;
    }
    /**
     * Called after the sealing of the compilation.
     * @param callback The callback to call when ready.
     * @see https://github.com/webpack/docs/wiki/plugins#seal
     */
    onCompilationAfterSeal() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.fixMissingCssEntries();
            this.alterCssChunks(this.compilation.assets, this.compilation.chunks);
        });
    }
    fixMissingCssEntries() {
        let allEntryNames = Object.keys(this.compilation.entrypoints);
        for (let name of allEntryNames) {
            if (this.cssEntries.has(name)) continue;
            let entrypoint = this.compilation.entrypoints[name];
            let hasOnlyCssModules = entrypoint.chunks.every(chunk => {
                let taggedModule = chunk.entryModule;
                return taggedModule && taggedModule[_models.isCssEntry] === true;
            });
            if (hasOnlyCssModules) {
                this.cssEntries.add(entrypoint.name);
            }
        }
    }
    alterCssChunks(assets, chunks) {
        for (let chunk of chunks) {
            if (!this.isCssChunk(chunk)) continue;
            this.alterCssChunk(assets, chunk);
        }
    }
    /**
     * Checks if the chunk is a CSS chunk.
     * @param chunk The chunk instance or chunk name.
     * @returns True if the chunk is a CSS chunk, or false otherwise.
     */
    isCssChunk(chunk) {
        let chunkName = chunk instanceof _webpack.Chunk ? chunk.name : chunk;
        return this.cssEntries.has(chunkName);
    }
    alterCssChunk(assets, chunk) {
        let cssFiles = [];
        for (let file of chunk.files) {
            if (file.match(/\.js(\.map)?$/)) {
                // Remove JS file from assets and chunk
                delete assets[file];
                continue;
            }
            // Keep CSS file
            cssFiles.push(file);
        }
        chunk.files = cssFiles;
    }
    reportBreakingChange(message) {
        if (!this.breakingChangeErrorReported) {
            this.addWarning(message + " (possible breaking change in Webpack)");
            this.breakingChangeErrorReported = true;
        }
    }
    addWarning(err) {
        if (typeof err === "string") {
            err = new _CssEntryPluginError2.default(err);
        }
        this.compilation.warnings.push(err);
        return err;
    }
}
exports.default = CssEntryCompilation;
module.exports = exports["default"];