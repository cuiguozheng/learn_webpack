"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizeOptions = normalizeOptions;

var _CssEntryPluginError = require("./CssEntryPluginError");

var _CssEntryPluginError2 = _interopRequireDefault(_CssEntryPluginError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Follow the standard https://webpack.js.org/configuration/output/#output-filename
const defaultOutputFilename = "[name].css",
      defaultExtensions = [".css", ".scss", ".less", ".styl"];
function normalizeOptions(options) {
    // Sanitize
    if (!options) {
        options = {};
    } else if (typeof options === "string" || typeof options === "function") {
        options = {
            output: {
                filename: options
            }
        };
    }
    if (typeof options !== "object") {
        throw new _CssEntryPluginError2.default("'options' should be of type string, function or object");
    }
    return {
        disable: !!options.disable,
        output: normalizeOutputOptions(options.output),
        includeCssEntry: makeIncludeCssEntry(options),
        isCssResource: makeIsCssResource(options)
    };
}
function normalizeOutputOptions(options) {
    // Sanitize
    if (!options || !options.filename) {
        return {
            filename: defaultOutputFilename
        };
    }
    if (typeof options !== "object") {
        throw new _CssEntryPluginError2.default("'output' option should be of type object");
    }
    if (typeof options.filename !== "string" && typeof options.filename !== "function") {
        throw new _CssEntryPluginError2.default("'output.filename' option should be of type string or function");
    }
    return {
        filename: options.filename
    };
}
function makeIncludeCssEntry(options) {
    if (options.entries && options.ignoreEntries) {
        throw new _CssEntryPluginError2.default("Both 'entries' and 'excludeEntries' specified");
    }
    if (options.entries) {
        return entryConditionToMatcher(options.entries);
    }
    if (options.ignoreEntries) {
        return entryConditionToMatcher(options.ignoreEntries, true);
    }
    return () => true;
}
function makeIsCssResource(options) {
    if (!options.extensions && !options.test) {
        options.extensions = defaultExtensions;
    }
    if (options.extensions && options.test) {
        throw new _CssEntryPluginError2.default("Both 'extensions' and 'test' specified");
    }
    if (options.extensions) {
        if (!Array.isArray(options.extensions) && typeof options.extensions !== "string") {
            throw new _CssEntryPluginError2.default("Option 'extensions' should be an array of strings or a string");
        }
        let extensions = Array.isArray(options.extensions) ? [...options.extensions] : [options.extensions];
        return (resource, entry) => {
            for (let ext of extensions) {
                if (resource.endsWith(ext)) return true;
            }
            return false;
        };
    }
    if (options.test) {
        if (typeof options.test !== "function" && !(options.test instanceof RegExp)) {
            throw new _CssEntryPluginError2.default("Option 'test' should be a function or a regular expression");
        }
        if (options.test instanceof RegExp) {
            let regexp = options.test;
            options.test = (resource, entry) => regexp.test(resource);
        }
        return options.test;
    }
    return () => true;
}
function entryConditionToMatcher(condition, negate = false) {
    let fn = entry => true;
    if (typeof condition === "string") {
        fn = entry => entry.name === condition;
    } else if (Array.isArray(condition)) {
        fn = entry => condition.indexOf(entry.name) !== -1;
    } else if (condition instanceof RegExp) {
        fn = entry => condition.test(entry.name);
    } else if (typeof condition === "function") {
        fn = condition;
    }
    return negate ? _ => !fn(_) : fn;
}